{"version":3,"file":"Slider.stories-ba58ed5a.js","sources":["../../node_modules/framer-motion/dist/es/value/use-motion-value.mjs","../../node_modules/framer-motion/dist/es/utils/transform.mjs","../../node_modules/framer-motion/dist/es/value/use-combine-values.mjs","../../node_modules/framer-motion/dist/es/value/use-computed.mjs","../../node_modules/framer-motion/dist/es/value/use-transform.mjs","../../node_modules/framer-motion/dist/es/value/use-motion-template.mjs","../../node_modules/framer-motion/dist/es/render/dom/utils/resolve-element.mjs","../../node_modules/framer-motion/dist/es/render/dom/scroll/observe.mjs","../../node_modules/framer-motion/dist/es/render/dom/scroll/supports.mjs","../../node_modules/framer-motion/dist/es/animation/GroupPlaybackControls.mjs","../../node_modules/framer-motion/dist/es/animation/utils/is-dom-keyframes.mjs","../../node_modules/framer-motion/dist/es/animation/utils/create-visual-element.mjs","../../node_modules/framer-motion/dist/es/easing/utils/create-generator-easing.mjs","../../node_modules/framer-motion/dist/es/animation/sequence/utils/calc-time.mjs","../../node_modules/framer-motion/dist/es/utils/wrap.mjs","../../node_modules/framer-motion/dist/es/easing/utils/get-easing-for-segment.mjs","../../node_modules/framer-motion/dist/es/animation/sequence/utils/edit.mjs","../../node_modules/framer-motion/dist/es/animation/sequence/utils/sort.mjs","../../node_modules/framer-motion/dist/es/animation/sequence/create.mjs","../../node_modules/framer-motion/dist/es/animation/animate.mjs","../../src/Slider/Slider.tsx"],"sourcesContent":["import { useContext, useState, useEffect } from 'react';\nimport { motionValue } from './index.mjs';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\nimport { useConstant } from '../utils/use-constant.mjs';\n\n/**\n * Creates a `MotionValue` to track the state and velocity of a value.\n *\n * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.\n *\n * ```jsx\n * export const MyComponent = () => {\n *   const scale = useMotionValue(1)\n *\n *   return <motion.div style={{ scale }} />\n * }\n * ```\n *\n * @param initial - The initial state.\n *\n * @public\n */\nfunction useMotionValue(initial) {\n    const value = useConstant(() => motionValue(initial));\n    /**\n     * If this motion value is being used in static mode, like on\n     * the Framer canvas, force components to rerender when the motion\n     * value is updated.\n     */\n    const { isStatic } = useContext(MotionConfigContext);\n    if (isStatic) {\n        const [, setLatest] = useState(initial);\n        useEffect(() => value.on(\"change\", setLatest), []);\n    }\n    return value;\n}\n\nexport { useMotionValue };\n","import { interpolate } from './interpolate.mjs';\n\nconst isCustomValueType = (v) => {\n    return typeof v === \"object\" && v.mix;\n};\nconst getMixer = (v) => (isCustomValueType(v) ? v.mix : undefined);\nfunction transform(...args) {\n    const useImmediate = !Array.isArray(args[0]);\n    const argOffset = useImmediate ? 0 : -1;\n    const inputValue = args[0 + argOffset];\n    const inputRange = args[1 + argOffset];\n    const outputRange = args[2 + argOffset];\n    const options = args[3 + argOffset];\n    const interpolator = interpolate(inputRange, outputRange, {\n        mixer: getMixer(outputRange[0]),\n        ...options,\n    });\n    return useImmediate ? interpolator(inputValue) : interpolator;\n}\n\nexport { transform };\n","import { useMotionValue } from './use-motion-value.mjs';\nimport { useIsomorphicLayoutEffect } from '../utils/use-isomorphic-effect.mjs';\nimport { cancelFrame, frame } from '../frameloop/frame.mjs';\n\nfunction useCombineMotionValues(values, combineValues) {\n    /**\n     * Initialise the returned motion value. This remains the same between renders.\n     */\n    const value = useMotionValue(combineValues());\n    /**\n     * Create a function that will update the template motion value with the latest values.\n     * This is pre-bound so whenever a motion value updates it can schedule its\n     * execution in Framesync. If it's already been scheduled it won't be fired twice\n     * in a single frame.\n     */\n    const updateValue = () => value.set(combineValues());\n    /**\n     * Synchronously update the motion value with the latest values during the render.\n     * This ensures that within a React render, the styles applied to the DOM are up-to-date.\n     */\n    updateValue();\n    /**\n     * Subscribe to all motion values found within the template. Whenever any of them change,\n     * schedule an update.\n     */\n    useIsomorphicLayoutEffect(() => {\n        const scheduleUpdate = () => frame.update(updateValue, false, true);\n        const subscriptions = values.map((v) => v.on(\"change\", scheduleUpdate));\n        return () => {\n            subscriptions.forEach((unsubscribe) => unsubscribe());\n            cancelFrame(updateValue);\n        };\n    });\n    return value;\n}\n\nexport { useCombineMotionValues };\n","import { collectMotionValues } from './index.mjs';\nimport { useCombineMotionValues } from './use-combine-values.mjs';\n\nfunction useComputed(compute) {\n    /**\n     * Open session of collectMotionValues. Any MotionValue that calls get()\n     * will be saved into this array.\n     */\n    collectMotionValues.current = [];\n    compute();\n    const value = useCombineMotionValues(collectMotionValues.current, compute);\n    /**\n     * Synchronously close session of collectMotionValues.\n     */\n    collectMotionValues.current = undefined;\n    return value;\n}\n\nexport { useComputed };\n","import { transform } from '../utils/transform.mjs';\nimport { useCombineMotionValues } from './use-combine-values.mjs';\nimport { useConstant } from '../utils/use-constant.mjs';\nimport { useComputed } from './use-computed.mjs';\n\nfunction useTransform(input, inputRangeOrTransformer, outputRange, options) {\n    if (typeof input === \"function\") {\n        return useComputed(input);\n    }\n    const transformer = typeof inputRangeOrTransformer === \"function\"\n        ? inputRangeOrTransformer\n        : transform(inputRangeOrTransformer, outputRange, options);\n    return Array.isArray(input)\n        ? useListTransform(input, transformer)\n        : useListTransform([input], ([latest]) => transformer(latest));\n}\nfunction useListTransform(values, transformer) {\n    const latest = useConstant(() => []);\n    return useCombineMotionValues(values, () => {\n        latest.length = 0;\n        const numValues = values.length;\n        for (let i = 0; i < numValues; i++) {\n            latest[i] = values[i].get();\n        }\n        return transformer(latest);\n    });\n}\n\nexport { useTransform };\n","import { useCombineMotionValues } from './use-combine-values.mjs';\nimport { isMotionValue } from './utils/is-motion-value.mjs';\n\n/**\n * Combine multiple motion values into a new one using a string template literal.\n *\n * ```jsx\n * import {\n *   motion,\n *   useSpring,\n *   useMotionValue,\n *   useMotionTemplate\n * } from \"framer-motion\"\n *\n * function Component() {\n *   const shadowX = useSpring(0)\n *   const shadowY = useMotionValue(0)\n *   const shadow = useMotionTemplate`drop-shadow(${shadowX}px ${shadowY}px 20px rgba(0,0,0,0.3))`\n *\n *   return <motion.div style={{ filter: shadow }} />\n * }\n * ```\n *\n * @public\n */\nfunction useMotionTemplate(fragments, ...values) {\n    /**\n     * Create a function that will build a string from the latest motion values.\n     */\n    const numFragments = fragments.length;\n    function buildValue() {\n        let output = ``;\n        for (let i = 0; i < numFragments; i++) {\n            output += fragments[i];\n            const value = values[i];\n            if (value) {\n                output += isMotionValue(value) ? value.get() : value;\n            }\n        }\n        return output;\n    }\n    return useCombineMotionValues(values.filter(isMotionValue), buildValue);\n}\n\nexport { useMotionTemplate };\n","import { invariant } from '../../../utils/errors.mjs';\n\nfunction resolveElements(elements, scope, selectorCache) {\n    var _a;\n    if (typeof elements === \"string\") {\n        let root = document;\n        if (scope) {\n            invariant(Boolean(scope.current), \"Scope provided, but no element detected.\");\n            root = scope.current;\n        }\n        if (selectorCache) {\n            (_a = selectorCache[elements]) !== null && _a !== void 0 ? _a : (selectorCache[elements] = root.querySelectorAll(elements));\n            elements = selectorCache[elements];\n        }\n        else {\n            elements = root.querySelectorAll(elements);\n        }\n    }\n    else if (elements instanceof Element) {\n        elements = [elements];\n    }\n    /**\n     * Return an empty array\n     */\n    return Array.from(elements || []);\n}\n\nexport { resolveElements };\n","import { frame, cancelFrame } from '../../../frameloop/frame.mjs';\n\nfunction observeTimeline(update, timeline) {\n    let prevProgress;\n    const onFrame = () => {\n        const { currentTime } = timeline;\n        const percentage = currentTime === null ? 0 : currentTime.value;\n        const progress = percentage / 100;\n        if (prevProgress !== progress) {\n            update(progress);\n        }\n        prevProgress = progress;\n    };\n    frame.update(onFrame, true);\n    return () => cancelFrame(onFrame);\n}\n\nexport { observeTimeline };\n","import { memo } from '../../../utils/memo.mjs';\n\nconst supportsScrollTimeline = memo(() => window.ScrollTimeline !== undefined);\n\nexport { supportsScrollTimeline };\n","import { observeTimeline } from '../render/dom/scroll/observe.mjs';\nimport { supportsScrollTimeline } from '../render/dom/scroll/supports.mjs';\n\nclass GroupPlaybackControls {\n    constructor(animations) {\n        this.animations = animations.filter(Boolean);\n    }\n    then(onResolve, onReject) {\n        return Promise.all(this.animations).then(onResolve).catch(onReject);\n    }\n    /**\n     * TODO: Filter out cancelled or stopped animations before returning\n     */\n    getAll(propName) {\n        return this.animations[0][propName];\n    }\n    setAll(propName, newValue) {\n        for (let i = 0; i < this.animations.length; i++) {\n            this.animations[i][propName] = newValue;\n        }\n    }\n    attachTimeline(timeline) {\n        const cancelAll = this.animations.map((animation) => {\n            if (supportsScrollTimeline() && animation.attachTimeline) {\n                animation.attachTimeline(timeline);\n            }\n            else {\n                animation.pause();\n                return observeTimeline((progress) => {\n                    animation.time = animation.duration * progress;\n                }, timeline);\n            }\n        });\n        return () => {\n            cancelAll.forEach((cancelTimeline, i) => {\n                if (cancelTimeline)\n                    cancelTimeline();\n                this.animations[i].stop();\n            });\n        };\n    }\n    get time() {\n        return this.getAll(\"time\");\n    }\n    set time(time) {\n        this.setAll(\"time\", time);\n    }\n    get speed() {\n        return this.getAll(\"speed\");\n    }\n    set speed(speed) {\n        this.setAll(\"speed\", speed);\n    }\n    get duration() {\n        let max = 0;\n        for (let i = 0; i < this.animations.length; i++) {\n            max = Math.max(max, this.animations[i].duration);\n        }\n        return max;\n    }\n    runAll(methodName) {\n        this.animations.forEach((controls) => controls[methodName]());\n    }\n    play() {\n        this.runAll(\"play\");\n    }\n    pause() {\n        this.runAll(\"pause\");\n    }\n    stop() {\n        this.runAll(\"stop\");\n    }\n    cancel() {\n        this.runAll(\"cancel\");\n    }\n    complete() {\n        this.runAll(\"complete\");\n    }\n}\n\nexport { GroupPlaybackControls };\n","function isDOMKeyframes(keyframes) {\n    return typeof keyframes === \"object\" && !Array.isArray(keyframes);\n}\n\nexport { isDOMKeyframes };\n","import { isSVGElement } from '../../render/dom/utils/is-svg-element.mjs';\nimport { SVGVisualElement } from '../../render/svg/SVGVisualElement.mjs';\nimport { HTMLVisualElement } from '../../render/html/HTMLVisualElement.mjs';\nimport { visualElementStore } from '../../render/store.mjs';\n\nfunction createVisualElement(element) {\n    const options = {\n        presenceContext: null,\n        props: {},\n        visualState: {\n            renderState: {\n                transform: {},\n                transformOrigin: {},\n                style: {},\n                vars: {},\n                attrs: {},\n            },\n            latestValues: {},\n        },\n    };\n    const node = isSVGElement(element)\n        ? new SVGVisualElement(options, {\n            enableHardwareAcceleration: false,\n        })\n        : new HTMLVisualElement(options, {\n            enableHardwareAcceleration: true,\n        });\n    node.mount(element);\n    visualElementStore.set(element, node);\n}\n\nexport { createVisualElement };\n","import { spring } from '../../animation/generators/spring/index.mjs';\nimport { calcGeneratorDuration, maxGeneratorDuration } from '../../animation/generators/utils/calc-duration.mjs';\nimport { millisecondsToSeconds } from '../../utils/time-conversion.mjs';\n\n/**\n * Create a progress => progress easing function from a generator.\n */\nfunction createGeneratorEasing(options, scale = 100) {\n    const generator = spring({ keyframes: [0, scale], ...options });\n    const duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);\n    return {\n        type: \"keyframes\",\n        ease: (progress) => generator.next(duration * progress).value / scale,\n        duration: millisecondsToSeconds(duration),\n    };\n}\n\nexport { createGeneratorEasing };\n","/**\n * Given a absolute or relative time definition and current/prev time state of the sequence,\n * calculate an absolute time for the next keyframes.\n */\nfunction calcNextTime(current, next, prev, labels) {\n    var _a;\n    if (typeof next === \"number\") {\n        return next;\n    }\n    else if (next.startsWith(\"-\") || next.startsWith(\"+\")) {\n        return Math.max(0, current + parseFloat(next));\n    }\n    else if (next === \"<\") {\n        return prev;\n    }\n    else {\n        return (_a = labels.get(next)) !== null && _a !== void 0 ? _a : current;\n    }\n}\n\nexport { calcNextTime };\n","const wrap = (min, max, v) => {\n    const rangeSize = max - min;\n    return ((((v - min) % rangeSize) + rangeSize) % rangeSize) + min;\n};\n\nexport { wrap };\n","import { wrap } from '../../utils/wrap.mjs';\nimport { isEasingArray } from './is-easing-array.mjs';\n\nfunction getEasingForSegment(easing, i) {\n    return isEasingArray(easing) ? easing[wrap(0, easing.length, i)] : easing;\n}\n\nexport { getEasingForSegment };\n","import { getEasingForSegment } from '../../../easing/utils/get-easing-for-segment.mjs';\nimport { removeItem } from '../../../utils/array.mjs';\nimport { mix } from '../../../utils/mix.mjs';\n\nfunction eraseKeyframes(sequence, startTime, endTime) {\n    for (let i = 0; i < sequence.length; i++) {\n        const keyframe = sequence[i];\n        if (keyframe.at > startTime && keyframe.at < endTime) {\n            removeItem(sequence, keyframe);\n            // If we remove this item we have to push the pointer back one\n            i--;\n        }\n    }\n}\nfunction addKeyframes(sequence, keyframes, easing, offset, startTime, endTime) {\n    /**\n     * Erase every existing value between currentTime and targetTime,\n     * this will essentially splice this timeline into any currently\n     * defined ones.\n     */\n    eraseKeyframes(sequence, startTime, endTime);\n    for (let i = 0; i < keyframes.length; i++) {\n        sequence.push({\n            value: keyframes[i],\n            at: mix(startTime, endTime, offset[i]),\n            easing: getEasingForSegment(easing, i),\n        });\n    }\n}\n\nexport { addKeyframes, eraseKeyframes };\n","function compareByTime(a, b) {\n    if (a.at === b.at) {\n        if (a.value === null)\n            return 1;\n        if (b.value === null)\n            return -1;\n        return 0;\n    }\n    else {\n        return a.at - b.at;\n    }\n}\n\nexport { compareByTime };\n","import { createGeneratorEasing } from '../../easing/utils/create-generator-easing.mjs';\nimport { resolveElements } from '../../render/dom/utils/resolve-element.mjs';\nimport { defaultOffset } from '../../utils/offsets/default.mjs';\nimport { fillOffset } from '../../utils/offsets/fill.mjs';\nimport { progress } from '../../utils/progress.mjs';\nimport { secondsToMilliseconds } from '../../utils/time-conversion.mjs';\nimport { isMotionValue } from '../../value/utils/is-motion-value.mjs';\nimport { calcNextTime } from './utils/calc-time.mjs';\nimport { addKeyframes } from './utils/edit.mjs';\nimport { compareByTime } from './utils/sort.mjs';\n\nconst defaultSegmentEasing = \"easeInOut\";\nfunction createAnimationsFromSequence(sequence, { defaultTransition = {}, ...sequenceTransition } = {}, scope) {\n    const defaultDuration = defaultTransition.duration || 0.3;\n    const animationDefinitions = new Map();\n    const sequences = new Map();\n    const elementCache = {};\n    const timeLabels = new Map();\n    let prevTime = 0;\n    let currentTime = 0;\n    let totalDuration = 0;\n    /**\n     * Build the timeline by mapping over the sequence array and converting\n     * the definitions into keyframes and offsets with absolute time values.\n     * These will later get converted into relative offsets in a second pass.\n     */\n    for (let i = 0; i < sequence.length; i++) {\n        const segment = sequence[i];\n        /**\n         * If this is a timeline label, mark it and skip the rest of this iteration.\n         */\n        if (typeof segment === \"string\") {\n            timeLabels.set(segment, currentTime);\n            continue;\n        }\n        else if (!Array.isArray(segment)) {\n            timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n            continue;\n        }\n        let [subject, keyframes, transition = {}] = segment;\n        /**\n         * If a relative or absolute time value has been specified we need to resolve\n         * it in relation to the currentTime.\n         */\n        if (transition.at !== undefined) {\n            currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);\n        }\n        /**\n         * Keep track of the maximum duration in this definition. This will be\n         * applied to currentTime once the definition has been parsed.\n         */\n        let maxDuration = 0;\n        const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numElements = 0) => {\n            const valueKeyframesAsList = keyframesAsList(valueKeyframes);\n            const { delay = 0, times = defaultOffset(valueKeyframesAsList), type = \"keyframes\", ...remainingTransition } = valueTransition;\n            let { ease = defaultTransition.ease || \"easeOut\", duration } = valueTransition;\n            /**\n             * Resolve stagger() if defined.\n             */\n            const calculatedDelay = typeof delay === \"function\"\n                ? delay(elementIndex, numElements)\n                : delay;\n            /**\n             * If this animation should and can use a spring, generate a spring easing function.\n             */\n            const numKeyframes = valueKeyframesAsList.length;\n            if (numKeyframes <= 2 && type === \"spring\") {\n                /**\n                 * As we're creating an easing function from a spring,\n                 * ideally we want to generate it using the real distance\n                 * between the two keyframes. However this isn't always\n                 * possible - in these situations we use 0-100.\n                 */\n                let absoluteDelta = 100;\n                if (numKeyframes === 2 &&\n                    isNumberKeyframesArray(valueKeyframesAsList)) {\n                    const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];\n                    absoluteDelta = Math.abs(delta);\n                }\n                const springTransition = { ...remainingTransition };\n                if (duration !== undefined) {\n                    springTransition.duration = secondsToMilliseconds(duration);\n                }\n                const springEasing = createGeneratorEasing(springTransition, absoluteDelta);\n                ease = springEasing.ease;\n                duration = springEasing.duration;\n            }\n            duration !== null && duration !== void 0 ? duration : (duration = defaultDuration);\n            const startTime = currentTime + calculatedDelay;\n            const targetTime = startTime + duration;\n            /**\n             * If there's only one time offset of 0, fill in a second with length 1\n             */\n            if (times.length === 1 && times[0] === 0) {\n                times[1] = 1;\n            }\n            /**\n             * Fill out if offset if fewer offsets than keyframes\n             */\n            const remainder = times.length - valueKeyframesAsList.length;\n            remainder > 0 && fillOffset(times, remainder);\n            /**\n             * If only one value has been set, ie [1], push a null to the start of\n             * the keyframe array. This will let us mark a keyframe at this point\n             * that will later be hydrated with the previous value.\n             */\n            valueKeyframesAsList.length === 1 &&\n                valueKeyframesAsList.unshift(null);\n            /**\n             * Add keyframes, mapping offsets to absolute time.\n             */\n            addKeyframes(valueSequence, valueKeyframesAsList, ease, times, startTime, targetTime);\n            maxDuration = Math.max(calculatedDelay + duration, maxDuration);\n            totalDuration = Math.max(targetTime, totalDuration);\n        };\n        if (isMotionValue(subject)) {\n            const subjectSequence = getSubjectSequence(subject, sequences);\n            resolveValueSequence(keyframes, transition, getValueSequence(\"default\", subjectSequence));\n        }\n        else {\n            /**\n             * Find all the elements specified in the definition and parse value\n             * keyframes from their timeline definitions.\n             */\n            const elements = resolveElements(subject, scope, elementCache);\n            const numElements = elements.length;\n            /**\n             * For every element in this segment, process the defined values.\n             */\n            for (let elementIndex = 0; elementIndex < numElements; elementIndex++) {\n                /**\n                 * Cast necessary, but we know these are of this type\n                 */\n                keyframes = keyframes;\n                transition = transition;\n                const element = elements[elementIndex];\n                const subjectSequence = getSubjectSequence(element, sequences);\n                for (const key in keyframes) {\n                    resolveValueSequence(keyframes[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), elementIndex, numElements);\n                }\n            }\n            prevTime = currentTime;\n            currentTime += maxDuration;\n        }\n    }\n    /**\n     * For every element and value combination create a new animation.\n     */\n    sequences.forEach((valueSequences, element) => {\n        for (const key in valueSequences) {\n            const valueSequence = valueSequences[key];\n            /**\n             * Arrange all the keyframes in ascending time order.\n             */\n            valueSequence.sort(compareByTime);\n            const keyframes = [];\n            const valueOffset = [];\n            const valueEasing = [];\n            /**\n             * For each keyframe, translate absolute times into\n             * relative offsets based on the total duration of the timeline.\n             */\n            for (let i = 0; i < valueSequence.length; i++) {\n                const { at, value, easing } = valueSequence[i];\n                keyframes.push(value);\n                valueOffset.push(progress(0, totalDuration, at));\n                valueEasing.push(easing || \"easeOut\");\n            }\n            /**\n             * If the first keyframe doesn't land on offset: 0\n             * provide one by duplicating the initial keyframe. This ensures\n             * it snaps to the first keyframe when the animation starts.\n             */\n            if (valueOffset[0] !== 0) {\n                valueOffset.unshift(0);\n                keyframes.unshift(keyframes[0]);\n                valueEasing.unshift(defaultSegmentEasing);\n            }\n            /**\n             * If the last keyframe doesn't land on offset: 1\n             * provide one with a null wildcard value. This will ensure it\n             * stays static until the end of the animation.\n             */\n            if (valueOffset[valueOffset.length - 1] !== 1) {\n                valueOffset.push(1);\n                keyframes.push(null);\n            }\n            if (!animationDefinitions.has(element)) {\n                animationDefinitions.set(element, {\n                    keyframes: {},\n                    transition: {},\n                });\n            }\n            const definition = animationDefinitions.get(element);\n            definition.keyframes[key] = keyframes;\n            definition.transition[key] = {\n                ...defaultTransition,\n                duration: totalDuration,\n                ease: valueEasing,\n                times: valueOffset,\n                ...sequenceTransition,\n            };\n        }\n    });\n    return animationDefinitions;\n}\nfunction getSubjectSequence(subject, sequences) {\n    !sequences.has(subject) && sequences.set(subject, {});\n    return sequences.get(subject);\n}\nfunction getValueSequence(name, sequences) {\n    if (!sequences[name])\n        sequences[name] = [];\n    return sequences[name];\n}\nfunction keyframesAsList(keyframes) {\n    return Array.isArray(keyframes) ? keyframes : [keyframes];\n}\nfunction getValueTransition(transition, key) {\n    return transition[key]\n        ? { ...transition, ...transition[key] }\n        : { ...transition };\n}\nconst isNumber = (keyframe) => typeof keyframe === \"number\";\nconst isNumberKeyframesArray = (keyframes) => keyframes.every(isNumber);\n\nexport { createAnimationsFromSequence, getValueTransition };\n","import { resolveElements } from '../render/dom/utils/resolve-element.mjs';\nimport { visualElementStore } from '../render/store.mjs';\nimport { invariant } from '../utils/errors.mjs';\nimport { GroupPlaybackControls } from './GroupPlaybackControls.mjs';\nimport { isDOMKeyframes } from './utils/is-dom-keyframes.mjs';\nimport { animateTarget } from './interfaces/visual-element-target.mjs';\nimport { createVisualElement } from './utils/create-visual-element.mjs';\nimport { animateSingleValue } from './interfaces/single-value.mjs';\nimport { createAnimationsFromSequence } from './sequence/create.mjs';\nimport { isMotionValue } from '../value/utils/is-motion-value.mjs';\n\nfunction animateElements(elementOrSelector, keyframes, options, scope) {\n    const elements = resolveElements(elementOrSelector, scope);\n    const numElements = elements.length;\n    invariant(Boolean(numElements), \"No valid element provided.\");\n    const animations = [];\n    for (let i = 0; i < numElements; i++) {\n        const element = elements[i];\n        /**\n         * Check each element for an associated VisualElement. If none exists,\n         * we need to create one.\n         */\n        if (!visualElementStore.has(element)) {\n            /**\n             * TODO: We only need render-specific parts of the VisualElement.\n             * With some additional work the size of the animate() function\n             * could be reduced significantly.\n             */\n            createVisualElement(element);\n        }\n        const visualElement = visualElementStore.get(element);\n        const transition = { ...options };\n        /**\n         * Resolve stagger function if provided.\n         */\n        if (typeof transition.delay === \"function\") {\n            transition.delay = transition.delay(i, numElements);\n        }\n        animations.push(...animateTarget(visualElement, { ...keyframes, transition }, {}));\n    }\n    return new GroupPlaybackControls(animations);\n}\nconst isSequence = (value) => Array.isArray(value) && Array.isArray(value[0]);\nfunction animateSequence(sequence, options, scope) {\n    const animations = [];\n    const animationDefinitions = createAnimationsFromSequence(sequence, options, scope);\n    animationDefinitions.forEach(({ keyframes, transition }, subject) => {\n        let animation;\n        if (isMotionValue(subject)) {\n            animation = animateSingleValue(subject, keyframes.default, transition.default);\n        }\n        else {\n            animation = animateElements(subject, keyframes, transition);\n        }\n        animations.push(animation);\n    });\n    return new GroupPlaybackControls(animations);\n}\nconst createScopedAnimate = (scope) => {\n    /**\n     * Implementation\n     */\n    function scopedAnimate(valueOrElementOrSequence, keyframes, options) {\n        let animation;\n        if (isSequence(valueOrElementOrSequence)) {\n            animation = animateSequence(valueOrElementOrSequence, keyframes, scope);\n        }\n        else if (isDOMKeyframes(keyframes)) {\n            animation = animateElements(valueOrElementOrSequence, keyframes, options, scope);\n        }\n        else {\n            animation = animateSingleValue(valueOrElementOrSequence, keyframes, options);\n        }\n        if (scope) {\n            scope.animations.push(animation);\n        }\n        return animation;\n    }\n    return scopedAnimate;\n};\nconst animate = createScopedAnimate();\n\nexport { animate, createScopedAnimate };\n","import {\n  animate,\n  motion,\n  useMotionTemplate,\n  useMotionValue,\n  useTransform,\n} from \"framer-motion\";\nimport scss from \"./Slider.module.scss\";\nimport { useEffect, useRef, useState } from \"react\";\nimport { SliderProps } from \"./Slider.types\";\n\nexport const Slider = ({ min = 0, max = 100, ...props }: SliderProps) => {\n  const buttonSize = 12;\n\n  const buttonX = useMotionValue(props.defaultValue ?? 0);\n  const progress = useTransform(buttonX, (v) => v + buttonSize / 2);\n  const background = useMotionTemplate`\n    linear-gradient(90deg, #423f40 ${progress.get()}px, #7f7d7e 0)`;\n\n  const buttonRef = useRef<HTMLButtonElement | null>(null);\n  const maxDragAreaRef = useRef<HTMLDivElement | null>(null);\n  const progressBarRef = useRef<HTMLDivElement | null>(null);\n  // if user don't have selected a slider value and you're using defaultValue, the sliderValue prop must be undefined\n  const [value, setValue] = useState(\n    props.sliderValue ?? props.defaultValue ?? 0\n  );\n\n  function clamp(number: number, min: number, max: number) {\n    return Math.max(min, Math.min(number, max));\n  }\n\n  function handleDrag() {\n    if (!buttonRef.current || !progressBarRef.current) return;\n\n    const buttonBounds = buttonRef.current.getBoundingClientRect();\n    const middleButton = buttonBounds.x + buttonBounds.width / 2;\n    const progressBarBounds = progressBarRef.current.getBoundingClientRect();\n    const newProgress =\n      (middleButton - progressBarBounds.x) / progressBarBounds.width;\n    setValue(newProgress * (max - min));\n  }\n\n  function handlePointerDown(ev: React.PointerEvent<HTMLDivElement>) {\n    if (!progressBarRef.current) return;\n\n    const { left, width } = progressBarRef.current.getBoundingClientRect();\n    const position = ev.pageX - left;\n    const newProgress = clamp(position / width, 0, 1);\n    const newValue = newProgress * (max - min);\n\n    setValue(newValue);\n    animate(buttonX, newProgress * width);\n  }\n\n  function handleKeyDown(ev: React.KeyboardEvent<HTMLButtonElement>) {\n    switch (ev.key) {\n      case \"ArrowLeft\":\n        if (value <= min) return;\n        setValue((prev) => (prev -= 1));\n        break;\n\n      case \"ArrowRight\":\n        if (value >= max) return;\n        setValue((prev) => (prev += 1));\n        break;\n\n      case \"Home\":\n        setValue(min);\n        break;\n\n      case \"End\":\n        setValue(max);\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  useEffect(() => {\n    if (!progressBarRef.current) return;\n    const newProgress = value / (max - min);\n    const progressBarBounds = progressBarRef.current.getBoundingClientRect();\n\n    buttonX.set(newProgress * progressBarBounds.width);\n  }, [buttonX, max, min, value]);\n\n  useEffect(() => {\n    if (props.setSliderValue) props.setSliderValue(value);\n  }, [props, value]);\n\n  return (\n    <div\n      role=\"slider\"\n      aria-valuemin={min}\n      aria-valuemax={max}\n      ref={maxDragAreaRef}\n      aria-valuenow={value}\n      className={scss.track}\n      aria-orientation=\"horizontal\"\n      style={{ background: background.get() }}\n      aria-valuetext={`the value of this slider is: ${value}`}\n    >\n      <div\n        className={scss.trackProgress}\n        ref={progressBarRef}\n        style={{\n          left: buttonSize / 2,\n          right: buttonSize / 2,\n        }}\n      />\n\n      <motion.button\n        drag=\"x\"\n        ref={buttonRef}\n        dragElastic={false}\n        onDrag={handleDrag}\n        dragMomentum={false}\n        style={{\n          width: buttonSize,\n          height: buttonSize,\n          x: buttonX,\n        }}\n        className={scss.button}\n        onKeyDown={handleKeyDown}\n        data-testid=\"trigger-button\"\n        dragConstraints={maxDragAreaRef}\n        whileDrag={{ cursor: \"grabbing\" }}\n        aria-label=\"button that trigger the slider\"\n      />\n      <div\n        data-testid=\"click-slider\"\n        onPointerDown={handlePointerDown}\n        className={scss.trackClick}\n      />\n    </div>\n  );\n};\n"],"names":["useMotionValue","initial","value","useConstant","motionValue","isStatic","useContext","MotionConfigContext","setLatest","useState","useEffect","isCustomValueType","v","getMixer","transform","args","useImmediate","argOffset","inputValue","inputRange","outputRange","options","interpolator","interpolate","useCombineMotionValues","values","combineValues","updateValue","useIsomorphicLayoutEffect","scheduleUpdate","frame","subscriptions","unsubscribe","cancelFrame","useComputed","compute","collectMotionValues","useTransform","input","inputRangeOrTransformer","transformer","useListTransform","latest","numValues","i","useMotionTemplate","fragments","numFragments","buildValue","output","isMotionValue","resolveElements","elements","scope","selectorCache","_a","root","invariant","observeTimeline","update","timeline","prevProgress","onFrame","currentTime","progress","supportsScrollTimeline","memo","GroupPlaybackControls","animations","onResolve","onReject","propName","newValue","cancelAll","animation","cancelTimeline","time","speed","max","methodName","controls","isDOMKeyframes","keyframes","createVisualElement","element","node","isSVGElement","SVGVisualElement","HTMLVisualElement","visualElementStore","createGeneratorEasing","scale","generator","spring","duration","calcGeneratorDuration","maxGeneratorDuration","millisecondsToSeconds","calcNextTime","current","next","prev","labels","wrap","min","rangeSize","getEasingForSegment","easing","isEasingArray","eraseKeyframes","sequence","startTime","endTime","keyframe","removeItem","addKeyframes","offset","mix","compareByTime","a","b","defaultSegmentEasing","createAnimationsFromSequence","defaultTransition","sequenceTransition","defaultDuration","animationDefinitions","sequences","elementCache","timeLabels","prevTime","totalDuration","segment","subject","transition","maxDuration","resolveValueSequence","valueKeyframes","valueTransition","valueSequence","elementIndex","numElements","valueKeyframesAsList","keyframesAsList","delay","times","defaultOffset","type","remainingTransition","ease","calculatedDelay","numKeyframes","absoluteDelta","isNumberKeyframesArray","delta","springTransition","secondsToMilliseconds","springEasing","targetTime","remainder","fillOffset","subjectSequence","getSubjectSequence","getValueSequence","key","getValueTransition","valueSequences","valueOffset","valueEasing","at","definition","name","isNumber","animateElements","elementOrSelector","visualElement","animateTarget","isSequence","animateSequence","animateSingleValue","createScopedAnimate","scopedAnimate","valueOrElementOrSequence","animate","Slider","props","buttonX","background","buttonRef","useRef","maxDragAreaRef","progressBarRef","setValue","clamp","number","min2","max2","handleDrag","buttonBounds","middleButton","progressBarBounds","newProgress","handlePointerDown","ev","left","width","position","handleKeyDown","jsxs","scss","jsx","motion"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]}